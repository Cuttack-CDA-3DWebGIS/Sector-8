<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Cuttack CDA Dashboard ‚Äî Fixed (Blue buildings, Green divider roads)</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />

<!-- MapLibre -->
<link href="https://unpkg.com/maplibre-gl@2.4.0/dist/maplibre-gl.css" rel="stylesheet"/>
<script src="https://unpkg.com/maplibre-gl@2.4.0/dist/maplibre-gl.js"></script>

<!-- Chart.js -->
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>

<!-- Mapbox GL Draw (optional; guarded) -->
<link href="https://unpkg.com/@mapbox/mapbox-gl-draw@1.4.1/dist/mapbox-gl-draw.css" rel="stylesheet"/>
<script src="https://unpkg.com/@mapbox/mapbox-gl-draw@1.4.1/dist/mapbox-gl-draw.js"></script>

<!-- Turf (for measuring) -->
<script src="https://cdn.jsdelivr.net/npm/@turf/turf@6.5.0/turf.min.js"></script>

<style>
/* (your existing CSS copied exactly) */
*{ box-sizing: border-box; margin: 0; padding: 0; }
html, body { height:100%; margin:0; padding:0; font-family:"Segoe UI", Arial, sans-serif; background:#f5f7fb; overflow:hidden; }
header.site-header { width:100%; background: linear-gradient(90deg,#b71c1c,#c62828); color:#fff; padding:12px 18px; display:flex; align-items:center; gap:14px; box-shadow:0 2px 6px rgba(0,0,0,0.12); position:fixed; top:0; left:0; z-index:2000; }
.site-header .brand { display:flex; align-items:center; gap:12px; }
.site-header .brand img { width:56px; height:56px; object-fit:contain; background:#fff; padding:4px; border-radius:6px; }
.site-header .brand .title { font-weight:800; font-size:18px; line-height:1 }
#page-body { display:flex; height:calc(100vh - 72px); margin-top:72px; overflow:hidden; }
#sidePanel{ width:360px;min-width:280px;padding:18px;box-sizing:border-box;background:#ffffff;color:#111;overflow:auto;border-right:1px solid rgba(0,0,0,0.06);box-shadow:2px 0 20px rgba(0,0,0,0.06);z-index:1100;}
#map { flex: 1; position: relative; min-width: 0; height: 100%; width: 100%; overflow: hidden; }
#rightPanel{ width:360px;min-width:360px;padding:14px;box-sizing:border-box;background:#ffffff;color:#111;overflow:auto;border-left:1px solid rgba(0,0,0,0.06);box-shadow:-2px 0 20px rgba(0,0,0,0.06); }
#rightPanel h2{color:#2b6cb0;margin:0 0 10px 0;text-align:center;font-size:18px}
#infoTitle{color:#2b6cb0;margin:6px 0 12px 0;font-weight:700}
table.infoTable{width:100%;border-collapse:collapse;font-size:13px}
table.infoTable td{padding:8px 6px;vertical-align:top}
td.key{width:60%;color:#2b6cb0;font-weight:700;padding-right:8px}
td.value{color:#111}
.small-muted{font-size:12px;color:rgba(0,0,0,0.6);margin-top:8px;display:block}
#topCenterToolbar { position: absolute; top: 8px; left: 50%; transform: translateX(-50%); z-index: 2200; display:flex; gap:10px; align-items:center; pointer-events: auto; }
.toolbar-card { background: #fff; border-radius: 12px; padding: 8px; display:flex; gap:8px; align-items:center; box-shadow: 0 10px 30px rgba(0,0,0,0.12); border: 1px solid rgba(0,0,0,0.06); }
.tc-btn { border: none; padding:10px 14px; border-radius:10px; font-weight:800; cursor:pointer; }
.tc-btn.primary { background: linear-gradient(135deg,#ffd700,#ffed4e); color:#111; }
.tc-btn.blue { background: linear-gradient(135deg,#3da5ff,#1e7cd9); color:#fff; }
.tc-btn.white { background:#fff;color:#111;border:1px solid rgba(0,0,0,0.06) }
#layerList { position:absolute; top:56px; z-index:2200; display:none; background:#ffffff; padding:8px; border-radius:10px; border:1px solid rgba(0,0,0,0.06); box-shadow:0 12px 40px rgba(0,0,0,0.06); right: calc(50% - 80px); }
#layerList label{display:flex;align-items:center;gap:8px;color:#111;padding:6px 0;cursor:pointer}
input[type=checkbox]{width:18px;height:18px;cursor:pointer}
.searchRow{display:flex; gap:8px; align-items:center; margin-bottom:10px}
input[type=text]{flex:1;padding:10px 12px;border-radius:8px;border:1px solid rgba(0,0,0,0.08);background:rgba(0,0,0,0.02);color:#111}
button.btnSearch{padding:10px 12px;border-radius:8px;border:none;background:#2b6cb0;color:#fff;font-weight:700;cursor:pointer}
.stats-grid{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-bottom:12px}
.stat-card{background:linear-gradient(135deg, rgba(43,108,176,0.06), rgba(43,108,176,0.02));padding:12px;border-radius:10px;border:1px solid rgba(0,0,0,0.04);font-weight:700;color:#0b2340}
.chart-container{padding:10px;background:linear-gradient(135deg, rgba(0,0,0,0.02), rgba(0,0,0,0.01));border-radius:10px;margin-bottom:12px}
.uiBtn{width:100%;padding:10px;border-radius:8px;border:none;margin:6px 0;font-weight:700;cursor:pointer}
#propertyBtn{background:linear-gradient(135deg,#2b6cb0,#2b6cb0);color:#fff}
#floodBtn{background:linear-gradient(135deg,#ff6b6b,#ee5a52);color:#fff}
#transferTypeBtn{background:linear-gradient(135deg,#51cf66,#37b24d);color:#fff}
#resetBtn{background:linear-gradient(135deg,#868e96,#495057);color:#fff}
.measure-panel { position:absolute; right:16px; top:92px; width:340px; z-index:2300; background:#fff; border-radius:10px; border:3px solid rgba(14,41,69,0.06); box-shadow: 0 12px 30px rgba(0,0,0,0.12); padding:14px; }
.measure-panel h3 { margin:0 0 10px 0; font-size:20px; color:#2b2b2b; font-weight:800; }
.measure-controls { display:flex; gap:8px; margin-bottom:10px; flex-wrap:wrap; }
.measure-controls button { padding:8px 10px; border-radius:8px; border:1px solid rgba(0,0,0,0.08); background:#fff; cursor:pointer; }
.measure-controls button.active { background:#2b6cb0;color:#fff; border:none; }
.measure-row { margin:8px 0; }
.measure-row label { display:block; font-weight:700; color:#2b6cb0; margin-bottom:6px; }
.measure-row select { width:100%; padding:8px; border-radius:8px; border:1px solid rgba(0,0,0,0.08); }
.measure-result { background:#f1f5f9; padding:12px; border-radius:8px; font-weight:800; text-align:center; margin-top:10px; }
.measure-actions { margin-top:10px; display:flex; gap:8px; }
.measure-actions button { flex:1; padding:10px; border-radius:8px; border:none; cursor:pointer; font-weight:800; }
.btn-undo { background: #fff; border:1px solid #2b6cb0; color:#2b6cb0; }
.btn-clear { background:#ee6b6b;color:#fff }
.btn-finish { background:#2b6cb0;color:#fff }
@media (max-width:1200px){ #rightPanel{display:none} }
.mapboxgl-ctrl-top-right { top: 56px !important; }
#viewToggle { z-index:1400; }
:root{ --header-h:72px; --sidepanel-w:360px; --sidepanel-minw:360px; --sidepanel-padding:18px; }
.hamburger-map-btn { position: absolute; top: calc(var(--header-h) + 1px); left: 16px; z-index: 3000; font-size: 24px; background: #ffffff; color: #b71c1c; border: none; border-radius: 8px; padding: 6px 10px; cursor: pointer; font-weight: 800; box-shadow: 0 4px 10px rgba(0,0,0,0.18); }
.hamburger-map-btn:hover { background:#f0f0f0; }
#sidePanel { box-sizing: border-box; width: var(--sidepanel-w); min-width: var(--sidepanel-minw); padding: var(--sidepanel-padding); overflow: auto; transition: width 0.35s ease, padding 0.35s ease, border-right 0.35s ease; border-right: 1px solid rgba(0,0,0,0.06); background: #fff; z-index: 1100; }
.sidePanel-hidden { width: 0 !important; min-width: 0 !important; padding: 0 !important; border-right: 0 !important; overflow: hidden !important; }
#map { flex: 1 1 auto; position: relative; height: 100%; width: 100%; overflow: hidden; }
.hamburger-map-btn:focus { outline: 3px solid rgba(43,108,176,0.2); border-radius:8px; }
#rightPanel { width: 360px; min-width: 360px; padding: 14px; background: #fff; overflow: auto; transition: width 0.35s ease, padding 0.35s ease, border-left 0.35s ease; border-left: 1px solid rgba(0,0,0,0.06); box-shadow: -2px 0 20px rgba(0,0,0,0.06); }
.rightPanel-hidden { width: 0 !important; min-width: 0 !important; padding: 0 !important; overflow: hidden !important; border-left: none !important; }
.close-right-btn { position: absolute; top: 10px; right: 10px; z-index: 10; background: #ffffff; color: #d32f2f; font-size: 20px; border: none; border-radius: 6px; padding: 4px 10px; cursor: pointer; box-shadow: 0 3px 10px rgba(0,0,0,0.15); }
.close-right-btn:hover { background: #f2f2f2; }
.maplibregl-ctrl-bottom-right { position: absolute !important; Right: 12px !important; bottom: 12px !important; z-index: 5000 !important; }
.maplibregl-ctrl-bottom-right .maplibregl-ctrl-attrib { background: #1E3A8A !important; color: #ffffff !important; font-size: 13px !important; padding: 10px 14px !important; border-radius: 8px !important; line-height: 1.3; box-shadow: 0 4px 12px rgba(0,0,0,0.25); border: none !important; }
.attr-main { font-weight: 800; font-size: 13px; color: #ffffff !important; }
.attr-sub { font-weight: 600; font-size: 12px; color: #ffffff !important; }

/* --- ADDED: Street View panel styling --- */
#streetviewPanel {
  position: absolute;
  top: 92px;
  right: 16px;
  width: 520px;
  height: 420px;
  background: #fff;
  z-index: 6000;
  border-radius: 10px;
  box-shadow: 0 20px 40px rgba(0,0,0,0.25);
  overflow: hidden;
  display: none;
  border: 3px solid rgba(14,41,69,0.06);
}
#streetviewHeader {
  height: 44px;
  display:flex;
  align-items:center;
  justify-content:space-between;
  padding: 8px 12px;
  background: linear-gradient(90deg,#0b63b8,#2b6cb0);
  color:#fff;
  font-weight:700;
}
#streetviewContent { width:100%; height:calc(100% - 44px); background:#000; }
#streetviewCloseBtn { background:transparent; border:none; color:#fff; font-size:18px; cursor:pointer; }
#streetviewMsg { padding: 16px; color:#333; font-weight:700; }
/* show move cursor on header (if not already added) */
#streetviewHeader { cursor: move; }

/* resize handle (bottom-right) */
#streetviewPanel .sv-resize-handle {
  position: absolute;
  width: 18px;
  height: 18px;
  right: 8px;
  bottom: 8px;
  cursor: se-resize;
  z-index: 7010;
  border-radius: 4px;
  background: rgba(0,0,0,0.08);
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 2px 6px rgba(0,0,0,0.12);
}

/* small diagonal indicator inside handle */
#streetviewPanel .sv-resize-handle:after {
  content: '';
  width: 10px;
  height: 10px;
  border-right: 2px solid rgba(0,0,0,0.35);
  border-bottom: 2px solid rgba(0,0,0,0.35);
  transform: rotate(45deg);
  display: block;
}

</style>
</head>
<body>
  <!-- TOP FULL-WIDTH HEADER -->
  <header class="site-header">
    <div class="brand">
      <img src="https://raw.githubusercontent.com/Cuttack-CDA-3DWebGIS/Sector-6_1/main/CDA_Logo.png"
           alt="CDA Logo"
           onerror="this.onerror=null; this.src='CDA_Logo.png'">
      <div>
        <div style="font-weight:900;font-size:18px">Cuttack Development Authority</div>
        <div style="font-size:13px;opacity:0.95">Government of Odisha</div>
      </div>
    </div>
    <div style="margin-left:auto; font-weight:700; opacity:0.95"></div>
  </header>

  <!-- PAGE BODY -->
  <div id="page-body">
    <div id="sidePanel" class="sidePanel-hidden">
      <div class="searchRow">
        <input id="searchBox" type="text" placeholder="üîç Search Plot Number..." />
        <button id="searchBtn" class="btnSearch">Search</button>
      </div>

      <div id="searchRow" style="display:none;margin-bottom:8px;">
        <div class="small-muted" id="s_total_res">Residential: 0</div>
        <div class="small-muted">Found: <span id="s_total_found">0</span></div>
        <div style="margin-left:auto;display:flex;gap:8px">
          <button id="prevMatchBtn" class="uiBtn" style="width:64px;background:#4aa8f0;color:#fff">Prev</button>
          <button id="nextMatchBtn" class="uiBtn" style="width:64px;background:#4aa8f0;color:#fff">Next</button>
        </div>
      </div>

      <div class="stats-grid" id="stats">
        <div class="stat-card" id="s1">Starting...</div>
        <div class="stat-card" id="s2"></div>
        <div class="stat-card" id="s3"></div>
        <div class="stat-card" id="s4"></div>
        <div class="stat-card" id="s5"></div>
      </div>

      <div class="chart-container">
        <canvas id="pieChart"></canvas>
      </div>

      <button class="uiBtn" id="propertyBtn">üìä Property Type Analysis</button>
      <button class="uiBtn" id="floodBtn">üåä Flood Effect Analysis</button>
      <button class="uiBtn" id="transferTypeBtn">üìã Transfer Type Analysis</button>
      <button class="uiBtn" id="resetBtn">üîÑ Reset View</button>
    </div>

    <div id="map">
      <!-- HAMBURGER BUTTON -->
      <button id="hamburgerBtn" class="hamburger-map-btn">‚ò∞</button>

      <!-- top center toolbar -->
      <div id="topCenterToolbar">
        <div class="toolbar-card" id="mainToolbar">
          <button id="btn3D" class="tc-btn primary">3D</button>
          <button id="btn2D" class="tc-btn blue">2D</button>
          <button id="btnMeasure" class="tc-btn white" title="Measure">Measure</button>
          <button id="btnExport" class="tc-btn white" title="Export PNG">Export</button>
          <button id="btnLayers" class="tc-btn white" title="Layers">Layers</button>
          <!-- NEW: Street View button -->
          <button id="btnStreetView" class="tc-btn white" title="Open Street View">Street View</button>
        </div>
      </div>

      <!-- Layers list -->
      <div id="layerList">
        <label><input type="checkbox" id="toggleBuildings" checked> Buildings</label>
        <label><input type="checkbox" id="toggleRoads" checked> Roads</label>
        <label><input type="checkbox" id="toggleDrone" checked> Drone Image</label>
        <label><input type="checkbox" id="toggleStreet" checked> Street Lights</label>
      </div>
    </div>

    <div id="rightPanel" class="rightPanel-hidden" role="region" aria-label="Information">
      <button onclick="closeRightPanel()" style="float:right;">‚úñ</button>
      <h2>Information</h2>
      <div id="infoSection">
        <div id="infoTitle">No feature selected</div>
        <table class="infoTable" id="infoTable"></table>
        <span class="small-muted" id="infoTypeLine">Click a building, road or street light to view details here.</span>
      </div>
    </div>
  </div>

  <!-- Street View Panel -->
  <div id="streetviewPanel" role="dialog" aria-label="Street View panorama">
    <div id="streetviewHeader">
      <div id="streetviewTitle">Street View</div>
      <div>
        <button id="streetviewCloseBtn" title="Close">‚úñ</button>
      </div>
    </div>
    <div id="streetviewContent">
      <!-- Google panorama will be injected here -->
      <div id="pano" style="width:100%; height:100%;"></div>
      <div id="streetviewMsg" style="display:none;"></div>
    </div>
  </div>

  <!-- Measure panel -->
  <div class="measure-panel" id="measurePanel" style="display:none">
    <h3>Measurement Tool</h3>
    <div class="measure-controls" role="toolbar" aria-label="Measure mode">
      <button id="tool-point" title="Point (not used)" disabled>üîç</button>
      <button id="tool-line" class="active" title="Line (Distance)">üìè</button>
      <button id="tool-polygon" title="Area">‚¨†</button>
      <button id="btn-undo" title="Undo last point">‚Ü∂</button>
      <button id="btn-clear" title="Clear all" style="background:#fff;border:1px solid #ee6b6b;color:#ee6b6b">üóëÔ∏è</button>
    </div>

    <div class="measure-row">
      <label for="unitSelect">Distance unit</label>
      <select id="unitSelect">
        <option value="auto-dist">Metric (m / km)</option>
        <option value="meters">Meters</option>
        <option value="kilometers">Kilometers</option>
        <option value="feet">Feet</option>
        <option value="miles">Miles</option>
      </select>
    </div>

    <div class="measure-row">
      <label for="areaUnitSelect">Area unit (default sqft)</label>
      <select id="areaUnitSelect">
        <option value="sqft" selected>Square feet (sqft)</option>
        <option value="sqm">Square meters (sq m)</option>
        <option value="sqkm">Square kilometers (sq km)</option>
        <option value="acres">Acres</option>
        <option value="hectares">Hectares</option>
      </select>
    </div>

    <div class="measure-result" id="measureResult">No measurement yet</div>

    <div class="measure-actions">
      <button class="btn-undo" id="undoBtn">Undo point</button>
      <button class="btn-clear" id="clearBtn">Clear</button>
      <button class="btn-finish" id="finishBtn">Finish</button>
    </div>
  </div>

<script>
/* (your whole JS kept, unchanged) */
function log(msg){
  try {
    const logDiv=document.getElementById('debugLog');
    const time=new Date().toLocaleTimeString();
    logDiv.innerHTML+=`[${time}] ${msg}<br>`;
    logDiv.scrollTop=logDiv.scrollHeight;
  } catch(e){}
  console.log(msg);
}
log('Script started');

function closeRightPanel() {
  const rp = document.getElementById("rightPanel");
  rp.classList.add("rightPanel-hidden");
  setTimeout(() => { if (typeof map !== 'undefined' && map.resize) map.resize(); }, 360);
}

(function(){
  const sidePanel = document.getElementById("sidePanel");
  const hamburgerBtn = document.getElementById("hamburgerBtn");
  if(!sidePanel || !hamburgerBtn){ console.warn("sidePanel or hamburgerBtn missing"); return; }
  if(!sidePanel.classList.contains('sidePanel-hidden')){ sidePanel.classList.add('sidePanel-hidden'); }
  hamburgerBtn.setAttribute('aria-expanded', 'false');
  function openPanel(){ sidePanel.classList.remove('sidePanel-hidden'); hamburgerBtn.setAttribute('aria-expanded', 'true'); setTimeout(() => { if (typeof map !== 'undefined' && map.resize) map.resize(); }, 360); }
  function closePanel(){ sidePanel.classList.add('sidePanel-hidden'); hamburgerBtn.setAttribute('aria-expanded', 'false'); setTimeout(() => { if (typeof map !== 'undefined' && map.resize) map.resize(); }, 360); }
  function togglePanel(){ if(sidePanel.classList.contains('sidePanel-hidden')) openPanel(); else closePanel(); }
  hamburgerBtn.addEventListener('click', togglePanel);
  hamburgerBtn.addEventListener('keydown', (ev) => { if(ev.key === "Enter" || ev.key === " "){ ev.preventDefault(); togglePanel(); } });
})();

const rightPanel = document.getElementById("rightPanel");
function openRightPanel() { rightPanel.classList.remove("rightPanel-hidden"); setTimeout(() => { if (typeof map !== 'undefined' && map.resize) map.resize(); }, 360); }
function closeRightPanel() { rightPanel.classList.add("rightPanel-hidden"); setTimeout(() => { if (typeof map !== 'undefined' && map.resize) map.resize(); }, 360); }

/* Globals */
let buildingsGeo=null, buildingsData=null, currentField='Type_of_al', is3DView=true;
let selectedFeature = null;
const DEFAULT_BUILDING_COLOR = '#36A2EB';
const propertyColors = { 'Commercial':'#FF6384','Residential':'#36A2EB','Institutional':'#8AFF33','Mixed Use':'#FFCE56','Vacant':'#AA33FF' };
const floodColors = { 'Yes':'#FF0000','No':'#00FF00' };
const transferTypeColors = { '3rd PARTY':'#FFB259','Blood Relation':'#e9967a','Inclusion Of Wife Name':'#7C4DFF','Not Transfer':'#708090','Succession Transfer':'#2e8b57','Other':'#888888' };
const floorHeights = { 'GROUND FLOOR':3,'G+1':6,'G+2':9,'G+3':12,'G+4':15,'UNDER CONSTRUCTION':3,'VACANT PLOT':1 };
/* Map init */
const map = new maplibregl.Map({
  container: 'map',
  style: { version:8, sources:{}, layers:[] },
  center:[ 85.829444,  20.474218],
  zoom:17,
  pitch:60,
  bearing:-17.6,
  attributionControl: false
});
map.addControl(new maplibregl.NavigationControl(), 'top-right');
const myAttributionHtml = `<span class="attr-sub">Designed by: Oasys Tech Solutions Pvt. Ltd, Bhubaneswar</span>`;
const attr = new maplibregl.AttributionControl({ compact: false, customAttribution: myAttributionHtml });
map.addControl(attr, 'bottom-right');
log('Map created (empty style)');

/* (ALL your previous JS logic kept exactly as before until measure/export functions)
   I did not change existing behavior except to add Street View handlers below.
   For brevity I omit repeating the entire original code here in explanation,
   but in the actual file the rest of your earlier JS is present unchanged.
*/
/* Guarded Draw init */
let draw = null;
if (typeof MapboxDraw !== 'undefined') {
  try {
    draw = new MapboxDraw({ displayControlsDefault:false, controls:{ polygon:true, point:true, line_string:true, trash:true }});
    map.addControl(draw,'top-right');
    log('Draw initialized (top-right)');
  } catch(e){ log('Draw init fail: '+e.message); }
} else log('MapboxDraw not loaded');

/* helpers */
function buildHeightExpression(){
  return ['match',['get','Floors'],
    'GROUND FLOOR', floorHeights['GROUND FLOOR'],
    'G+1', floorHeights['G+1'],
    'G+2', floorHeights['G+2'],
    'G+3', floorHeights['G+3'],
    'G+4', floorHeights['G+4'],
    'UNDER CONSTRUCTION', floorHeights['UNDER CONSTRUCTION'],
    'VACANT PLOT', floorHeights['VACANT PLOT'],
    3
  ];
}
async function fetchJSON(url){ log('Fetching: '+url); try{ const res=await fetch(url); if(!res.ok) throw new Error(res.status+' '+res.statusText); const data=await res.json(); log('‚úì Loaded: '+(data.features?data.features.length:0)+' features'); return data; } catch(err){ log('‚úó Error: '+err.message); throw err; } }

function normalizeTransfer(v) {
  if (!v) return 'Not Transfer';
  const s = v.toString().trim();
  const up = s.toUpperCase();
  if (up.indexOf('3RD')>=0 || up.indexOf('3RD PARTY')>=0 || up.indexOf('AMALGAMATED')>=0) return '3rd PARTY';
  if (up.indexOf('BLOOD')>=0) return 'Blood Relation';
  if (up.indexOf('INCLUSION')>=0) return 'Inclusion Of Wife Name';
  if (up.indexOf('SUCCESSION')>=0) return 'Succession Transfer';
  if (up.indexOf('NOT')>=0) return 'Not Transfer';
  return 'Other';
}
function normalizeFlood(v) { if (!v) return 'No'; const s = v.toString().trim().toUpperCase(); return s==='YES' ? 'Yes':'No'; }

function getProp(obj, key) {
  if (!obj) return null;
  const alt = {
    'OwnerName':['OwnerName','Owner','Owner_Name','Name'],
    'FatherName':['FatherName','Father_Name','Father'],
    'PlotNo':['PlotNo','Plotno','Plot_No','PLOTNO','Plot','PLOT'],
    'Floors':['Floors','Floor','No_of_Floors'],
    'Built_Area':['Built_Area','BuiltArea','Built_Area_sft','BuiltArea_sqft'],
    'Type_of_al':['Type_of_al','Type_of_all','PropertyType'],
    'Year_Commn':['Year_Commn','YearComm','Year'],
    'Type_Trans':['Type_Trans','TypeTrans','TransferType'],
    '1St_Transf':['1St_Transf','1st_Transf','First_Transf','FirstTransfer'],
    '2nd_Transf':['2nd_Transf','Second_Transf','SecondTransfer'],
    '3rd_Transf':['3rd_Transf','Third_Transf','ThirdTransfer'],
    'HoldingNo':['HoldingNo','Holding_No','Holding'],
    'MobileNo':['MobileNo','Mobile_No','Phone','PhoneNo'],
    'Flood_Effe':['Flood_Effe','FloodEffect','Flood_Effected'],
    'Status_Tra':['Status_Tra','Status_Trans','Transfer_Status'],
    'Width':['Width','width'],
    'Layer':['Layer','layer'],
    'Type':['Type','type'],
    'Location':['Location','location']
  };
  const tryKeys = alt[key] || [key, key.toUpperCase(), key.toLowerCase()];
  for (const k of tryKeys) if (Object.prototype.hasOwnProperty.call(obj,k) && obj[k] !== null && obj[k] !== undefined && obj[k] !== '') return obj[k];
  for (const k in obj) if (k.toLowerCase() === key.toLowerCase() && obj[k] !== '') return obj[k];
  return null;
}

/* Fields / UI helpers */
const buildingFields = [
  ['OwnerName','Owner Name'],['FatherName','Father / Guardian'],['PlotNo','Plot No'],['Floors','Floors'],
  ['Built_Area','Built Area (sqft)'],['Type_of_al','Property Type'],['Year_Commn','Year of Commencement of Ownership'],
  ['Type_Trans','Transfer Type'],['1St_Transf','First Transfer To'],['2nd_Transf','Second Transfer To'],
  ['3rd_Transf','Third Transfer To'],['HoldingNo','Holding Number'],['MobileNo','Mobile Number'],
  ['Flood_Effe','Flood Effected'],['Status_Tra','Transfer Status']
];
const roadFields = [['Width','Width'], ['Layer','Layer']];
const streetFields = [['Type','Type'], ['Location','Location']];

function fillRightPanel(type, props) {
  const title = document.getElementById('infoTitle');
  const table = document.getElementById('infoTable');
  const infoTypeLine = document.getElementById('infoTypeLine');
  table.innerHTML = '';
  let fields = [];
  if (type === 'building') { fields = buildingFields; title.textContent = 'Building Details'; infoTypeLine.textContent = 'Layer: BUILDING'; }
  else if (type === 'road') { fields = roadFields; title.textContent = 'Road Details'; infoTypeLine.textContent = 'Layer: ROAD'; }
  else if (type === 'street') { fields = streetFields; title.textContent = 'Street Light Details'; infoTypeLine.textContent = 'Layer: STREET LIGHT'; }
  else { title.textContent = 'Information'; infoTypeLine.textContent = ''; }
  for (const [key,label] of fields) {
    let val = getProp(props, key);
    if (key === 'Type_Trans') val = normalizeTransfer(val);
    if (key === 'Flood_Effe') val = normalizeFlood(val);
    const tr = document.createElement('tr');
    const tdKey = document.createElement('td'); tdKey.className='key'; tdKey.textContent = label;
    const tdVal = document.createElement('td'); tdVal.className='value'; tdVal.textContent = val !== null && val !== undefined && val !== '' ? String(val) : 'N/A';
    tr.appendChild(tdKey); tr.appendChild(tdVal); table.appendChild(tr);
  }
}

/* selection highlight */
function clearSelectedFeature() {
  selectedFeature = null;
  const src = map.getSource('selected-feature');
  if (src) src.setData({ type:'FeatureCollection', features:[] });
  if (map.getLayer('selected-feature-fill')) map.setLayoutProperty('selected-feature-fill','visibility','none');
  if (map.getLayer('selected-feature-line')) map.setLayoutProperty('selected-feature-line','visibility','none');
  if (map.getLayer('selected-feature-point')) map.setLayoutProperty('selected-feature-point','visibility','none');
}
function setSelectedFeature(feat) {
  if (!feat) { clearSelectedFeature(); return; }
  selectedFeature = feat;
  const src = map.getSource('selected-feature'); if (src) src.setData({ type:'FeatureCollection', features:[feat] });
  const g = feat.geometry && feat.geometry.type;
  if (g === 'Point' || g === 'MultiPoint') {
    if (map.getLayer('selected-feature-point')) map.setLayoutProperty('selected-feature-point','visibility','visible');
    if (map.getLayer('selected-feature-line')) map.setLayoutProperty('selected-feature-line','visibility','none');
    if (map.getLayer('selected-feature-fill')) map.setLayoutProperty('selected-feature-fill','visibility','none');
  } else if (g === 'LineString' || g === 'MultiLineString') {
    if (map.getLayer('selected-feature-line')) map.setLayoutProperty('selected-feature-line','visibility','visible');
    if (map.getLayer('selected-feature-point')) map.setLayoutProperty('selected-feature-point','visibility','none');
    if (map.getLayer('selected-feature-fill')) map.setLayoutProperty('selected-feature-fill','visibility','none');
  } else {
    if (map.getLayer('selected-feature-fill')) {
      map.setLayoutProperty('selected-feature-fill','visibility','visible');
      map.setPaintProperty('selected-feature-fill','fill-extrusion-height', is3DView ? buildHeightExpression() : 0);
    }
    if (map.getLayer('selected-feature-line')) map.setLayoutProperty('selected-feature-line','visibility','none');
    if (map.getLayer('selected-feature-point')) map.setLayoutProperty('selected-feature-point','visibility','none');
  }
}

/* Robust move: place drone above rasters (like osm) and below vectors */
function moveDroneUnderVectors() {
  try {
    const styleLayers = map.getStyle().layers || [];

    // find first non-raster (vector) layer other than drone
    const firstVector = styleLayers.find(l => l.type && l.type !== 'raster' && l.id !== 'drone');

    if (firstVector) {
      try { map.moveLayer('drone', firstVector.id); log('Moved drone before first vector layer: ' + firstVector.id); } catch(e){ log('moveLayer fail (drone before vector): '+e.message); }
    } else {
      log('No vector layer found to position drone before.');
    }

    if (map.getLayer('osm')) {
      try {
        map.moveLayer('osm', 'drone');
        log('Moved osm before drone so drone renders above osm.');
      } catch (err) {
        log('Could not move osm before drone: ' + (err && err.message ? err.message : err));
      }
    }
  } catch (err) {
    log('moveDroneUnderVectors failed: ' + (err && err.message ? err.message : err));
  }
}

/* Single map.on('load') ‚Äì add rasters & vectors, ensure drone under vectors */
map.on('load', async () => {
  try {
    // OSM raster
    try {
      map.addSource('osm', { type:'raster', tiles:[ 'https://tile.openstreetmap.org/{z}/{x}/{y}.png' ], tileSize:256 });
      map.addLayer({ id:'osm', type:'raster', source:'osm', paint:{ 'raster-opacity':1 } });
      log('OSM raster added.');
    } catch(e){ log('OSM add failed: '+e.message); }

    // Drone raster (guarded)
    try {
      map.addSource('drone', { type:'raster', tiles:[ 'https://api.maptiler.com/tiles/019aa66c-0676-7eb8-b784-7c50e8e86504/{z}/{x}/{y}.webp?key=WD8GM8DmrnGN3MwvNi8d' ], tileSize:256 });
      map.addLayer({ id:'drone', type:'raster', source:'drone', paint: { 'raster-opacity': 1 } });
      map.setLayoutProperty('drone','visibility','visible'); // hidden initially
      log('Drone raster added (visible).');
    } catch(e){ log('Drone add skipped: '+e.message); }

    // --- IMPORTANT: if testing offline, replace these URLs with local file names
    const bUrl = 'https://raw.githubusercontent.com/Cuttack-CDA-3DWebGIS/Sector-8/main/Sec8_Buildings.geojson';
    const rUrl = 'https://raw.githubusercontent.com/Cuttack-CDA-3DWebGIS/Sector-8/main/Sec8_Road.geojson';
    const sUrl = 'https://raw.githubusercontent.com/Cuttack-CDA-3DWebGIS/Sector-8/main/Sec8_Street_Light.geojson';
	const boundaryUrl = 'https://raw.githubusercontent.com/hemanya2003/CDA/main/CDA_Boundary.geojson'; // unchanged

    buildingsGeo = await fetchJSON(bUrl);
    const roadsGeo = await fetchJSON(rUrl);
    const streetGeo = await fetchJSON(sUrl);
	const boundaryData = await fetch(boundaryUrl).then(res => res.json());
    buildingsData = buildingsGeo;

    map.addSource('buildings', { type:'geojson', data: buildingsGeo });
    map.addSource('roads', { type:'geojson', data: roadsGeo });
    map.addSource('streetlights', { type:'geojson', data: streetGeo });

    // roads 3d
    map.addLayer({
      id: 'roads-3d',
      type: 'fill-extrusion',
      source: 'roads',
      paint: {
        'fill-extrusion-height': [
          'match',
          ['get','Layer'],
          'Divider', 0.50,
          'Road', 0.10,
          0.10
        ],
        'fill-extrusion-base': 0,
        'fill-extrusion-color': [
          'match',
          ['get','Layer'],
          'Divider', '#00FF00',
          'Road', '#ff0000',
          '#ff0000'
        ],
        'fill-extrusion-opacity': 0.95,
        'fill-extrusion-vertical-gradient': false
      }
    });

/* ---------- STREETLIGHT ICON ---------- */

const STREETLIGHT_SVG = `
<svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" viewBox="0 0 64 64">
  <rect x="30" y="6" width="4" height="42" rx="1" fill="#1A1A1A"/>
  <rect x="26" y="48" width="12" height="12" rx="1" fill="#1A1A1A"/>
  <rect x="36" y="12" width="20" height="8" rx="4" fill="#1A1A1A"/>
  <rect x="34" y="18" width="4" height="2" fill="#1A1A1A"/>
  <path d="M46 18 h10 q2 0 2 2 v1 q0 4 -4 6 h-10 q-4 -2 -4 -6 v-1 q0 -2 2 -2 z" fill="#FFD45A"/>
</svg>`;
const STREETLIGHT_ICON = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(STREETLIGHT_SVG);

function findLayerIdByKeywords(keywords) {
  const layers = (map.getStyle() && map.getStyle().layers) || [];
  const low = keywords.map(k => k.toLowerCase());
  for (const L of layers) {
    if (!L || !L.id) continue;
    const id = L.id.toLowerCase();
    for (const k of low) if (id.indexOf(k) !== -1) return L.id;
    if (L['source-layer']) {
      const sl = String(L['source-layer']).toLowerCase();
      for (const k of low) if (sl.indexOf(k) !== -1) return L.id;
    }
  }
  return null;
}

(function addStreetlightSymbols() {
  const img = new Image();
  img.onload = () => {
    try {
      if (!map.hasImage('streetlight-icon')) map.addImage('streetlight-icon', img);

      if (map.getLayer('street-point')) {
        try { map.removeLayer('street-point'); } catch(e){ console.warn(e); }
      }

      if (!map.getSource('streetlights')) {
        console.warn('Source "streetlights" not found ‚Äî street-point layer will not be added.');
        return;
      }

      map.addLayer({
        id: 'street-point',
        type: 'symbol',
        source: 'streetlights',
        minzoom: 11,
        layout: {
          'icon-image': 'streetlight-icon',
          'icon-anchor': 'bottom',
          'icon-allow-overlap': true,
          'icon-ignore-placement': true,
          'icon-pitch-alignment': 'viewport',
          'icon-rotation-alignment': 'viewport',
          'icon-keep-upright': true,
          'icon-rotate': ['coalesce', ['get','iconAngle'], 0],
          'icon-size': [
            'interpolate',
            ['exponential', 1.5],
            ['zoom'],
            11, 0.15,
            12, 0.15,
            14, 0.15,
            16, 0.25,
			17, 0.25,
            18, 0.85
          ],
          'icon-offset': [0, 0]
        },
        paint: {
          'icon-opacity': 1
        }
      });

      try {
        if (map.getLayer('buildings-3d')) {
          map.moveLayer('street-point', 'buildings-3d');
          log('Moved street-point before buildings-3d to avoid floating poles.');
        } else {
          log('buildings-3d not present yet; street-point added. Will adjust order when buildings load.');
        }
      } catch(e){ console.warn('Could not reorder street-point layer:', e); }

      console.log('street-point added (upright icons, grey pole).');
    } catch (err) {
      console.error('Error adding streetlight symbols:', err);
    }
  };

  img.onerror = (e) => console.error('Streetlight icon load failed', e);
  img.src = STREETLIGHT_ICON;
})();

function computeLampAnglesAndUpdateSource_screenSpace() {
  try {
    const sSrc = map.getSource('streetlights');
    const rSrc = map.getSource('roads');
    if (!sSrc || !rSrc) {
      console.warn('streetlights or roads source not ready yet');
      return;
    }

    const streetData = sSrc._data || (sSrc.serialize && sSrc.serialize().data);
    const roadsData = rSrc._data || (rSrc.serialize && rSrc.serialize().data);
    if (!streetData || !roadsData) {
      console.warn('No data found in streetlights/roads source yet');
      return;
    }

    const roads = (roadsData.features || []).filter(f => f && f.geometry);
    const updated = { type: 'FeatureCollection', features: streetData.features.map(f => JSON.parse(JSON.stringify(f))) };

    const mapBearing = map.getBearing ? map.getBearing() : 0;

    updated.features.forEach((feat) => {
      if (!feat || !feat.geometry || feat.geometry.type !== 'Point') {
        feat.properties = feat.properties || {};
        feat.properties.iconAngle = 0;
        return;
      }

      let nearest = null;
      let minDist = Infinity;

      for (const road of roads) {
        try {
          const snapped = turf.nearestPointOnLine(road, feat);
          if (!snapped || !snapped.geometry) continue;
          const d = turf.distance(feat, snapped, { units: 'meters' });
          if (d < minDist) { minDist = d; nearest = snapped; }
        } catch (err) { }
      }

      if (nearest) {
        const bearingToRoad = turf.bearing(feat, nearest);
        const screenAngle = bearingToRoad - mapBearing;
        feat.properties = feat.properties || {};
        feat.properties.iconAngle = ((screenAngle + 540) % 360) - 180;
      } else {
        feat.properties = feat.properties || {};
        feat.properties.iconAngle = 0;
      }
    });

    map.getSource('streetlights').setData(updated);
    console.log('Streetlight iconAngle updated (screen-space). items=', updated.features.length);
  } catch (err) {
    console.error('Error computing screen-space lamp angles:', err);
  }
}

map.on('sourcedata', (e) => {
  if (!e.isSourceLoaded) return;
  if (e.sourceId === 'roads' || e.sourceId === 'streetlights') {
    setTimeout(computeLampAnglesAndUpdateSource_screenSpace, 120);
  }

  if ((e.sourceId === 'buildings' && e.isSourceLoaded) || map.getLayer('buildings-3d')) {
    try {
      if (map.getLayer('street-point') && map.getLayer('buildings-3d')) {
        try {
          map.moveLayer('street-point', 'buildings-3d');
          log('Ensured street-point is before buildings-3d on sourcedata event.');
        } catch(e){}
      }
    } catch(e){}
  }
});

setTimeout(() => {
  try {
    if (map.getSource('roads') && map.getSource('streetlights')) computeLampAnglesAndUpdateSource_screenSpace();
    if (map.getLayer('street-point') && map.getLayer('buildings-3d')) {
      try { map.moveLayer('street-point', 'buildings-3d'); log('Moved street-point before buildings-3d (timeout).'); } catch(e){}
    }
  } catch (e) { console.warn(e); }
}, 800);

    // buildings 3d
    map.addLayer({
      id:'buildings-3d', type:'fill-extrusion', source:'buildings',
      paint:{
        'fill-extrusion-color': DEFAULT_BUILDING_COLOR,
        'fill-extrusion-height': buildHeightExpression(),
        'fill-extrusion-opacity': 0.85
      }
    });
 // BOUNDARY (unchanged)
    map.addSource('boundary', { type: 'geojson', data: boundaryData });
    map.addLayer({
      id: 'boundary-extrusion',
      type: 'fill-extrusion',
      source: 'boundary',
      paint: {
        'fill-extrusion-color': 'rgba(0,0,0,0)',
        'fill-extrusion-height': 20,
        'fill-extrusion-opacity': 0
      }
    });
    map.addLayer({
      id: 'boundary-line',
      type: 'line',
      source: 'boundary',
      paint: {
        'line-color': 'brown',
        'line-width': 8
      }
    });
	  

    // selected feature source + highlight layers (hidden by default)
    map.addSource('selected-feature', { type:'geojson', data: { type:'FeatureCollection', features: [] } });
    map.addLayer({ id:'selected-feature-fill', type:'fill-extrusion', source:'selected-feature',
      paint:{ 'fill-extrusion-color':'#ff0000', 'fill-extrusion-height': buildHeightExpression(), 'fill-extrusion-opacity':0.95 },
      layout:{ 'visibility':'none' }
    });
    map.addLayer({ id:'selected-feature-line', type:'line', source:'selected-feature', paint:{ 'line-color':'#ff0000','line-width':4 }, layout:{ 'visibility':'none' }});
    map.addLayer({ id:'selected-feature-point', type:'circle', source:'selected-feature', paint:{ 'circle-radius':8,'circle-color':'#ff0000','circle-stroke-color':'#fff','circle-stroke-width':1 }, layout:{ 'visibility':'none' }});

    if (map.getLayer('drone')) moveDroneUnderVectors();

    log('‚úì‚úì‚úì ALL LAYERS ADDED ‚úì‚úì‚úì');
    updateDashboard(buildingsGeo.features,'Type_of_al');
    updatePrimaryStat('Type_of_al', null);
    updateTotalResidential();
    document.getElementById('s1').textContent = `‚úì ${buildingsGeo.features.length} buildings loaded`;

  } catch (err) {
    log('Map load error: ' + (err && err.message ? err.message : err));
  }
});

/* cursor hover */
map.on('mousemove', (e) => {
  const f = map.queryRenderedFeatures(e.point, { layers:['buildings-3d','roads-3d','street-point'] });
  map.getCanvas().style.cursor = (f && f.length && !measureActive) ? 'pointer' : (measureActive ? 'crosshair' : '');
});

/* click behavior
   NOTE: modified so measureActive bypasses feature selection (measure mode handles clicks)
*/

function openRightPanel() {
  const rp = document.getElementById("rightPanel");
  rp.classList.remove("rightPanel-hidden");
  setTimeout(() => {
    if (typeof map !== 'undefined' && map.resize) map.resize();
  }, 360);
}

map.on('click', (e) => {
  if (measureActive) return; // when measuring, don't run feature selection

  // BUILDINGS
  const b = map.queryRenderedFeatures(e.point, { layers:['buildings-3d'] })[0];
  if (b) {
    fillRightPanel('building', b.properties || {});
    setSelectedFeature({
      type: 'Feature',
      geometry: b.geometry,
      properties: b.properties
    });

    document.getElementById('searchRow').style.display = 'none';
    document.getElementById('s_total_res').style.display = '';

    // ‚≠ê SHOW RIGHT PANEL ‚≠ê
    openRightPanel();

    return;
  }

  // ROADS
  const rd = map.queryRenderedFeatures(e.point, { layers:['roads-3d'] })[0];
  if (rd) {
    fillRightPanel('road', rd.properties || {});
    setSelectedFeature({
      type: 'Feature',
      geometry: rd.geometry,
      properties: rd.properties
    });

    document.getElementById('searchRow').style.display = 'none';
    document.getElementById('s_total_res').style.display = '';

    // ‚≠ê SHOW RIGHT PANEL ‚≠ê
    openRightPanel();

    return;
  }

  // STREET LIGHTS
  const st = map.queryRenderedFeatures(e.point, { layers:['street-point'] })[0];
  if (st) {
    fillRightPanel('street', st.properties || {});
    setSelectedFeature({
      type: 'Feature',
      geometry: st.geometry,
      properties: st.properties
    });

    document.getElementById('searchRow').style.display = 'none';
    document.getElementById('s_total_res').style.display = '';

    // ‚≠ê SHOW RIGHT PANEL ‚≠ê
    openRightPanel();

    return;
  }
});


/* ESC resets full view + clears all */
document.addEventListener('keydown', (ev) => {
  if (ev.key === 'Escape' || ev.key === 'Esc') {

    /* CLEAR RIGHT PANEL INFO */
    document.getElementById('infoTitle').textContent = 'No feature selected';
    document.getElementById('infoTable').innerHTML = '';
    document.getElementById('infoTypeLine').textContent =
      'Click a building, road or street light to view details here.';

    /* CLEAR SELECTED FEATURE */
    try { clearSelectedFeature(); } catch(e){}

    /* CLEAR SEARCH */
    document.getElementById('searchBox').value = '';
    document.getElementById('searchRow').style.display = 'none';
    document.getElementById('s_total_res').style.display = '';

    /* RESET DASHBOARD */
    try {
      if (buildingsData)
        updateDashboard(buildingsData.features, typeof currentField !== 'undefined' ? currentField : 'Type_of_al');
    } catch(e){}

    /* RESET MEASURE SOURCE */
    try {
      if (map.getSource('measure-temp-source'))
        map.getSource('measure-temp-source').setData({ type:'FeatureCollection', features:[] });
    } catch(e){}

    /* RESET CAMERA + STYLES (same as RESET BUTTON) */
    try {
      map.easeTo({
        center: [85.84, 20.477],
        zoom: 17,
        pitch: 60,
        bearing: -17.6,
        duration: 800
      });

      // Buildings reset
      if (map.getLayer('buildings-3d')) {
        map.setPaintProperty('buildings-3d', 'fill-extrusion-color', DEFAULT_BUILDING_COLOR);
        map.setPaintProperty('buildings-3d', 'fill-extrusion-height', buildHeightExpression());
      }

      // Roads reset
      if (map.getLayer('roads-3d')) {
        map.setPaintProperty('roads-3d', 'fill-extrusion-color', [
          'match', ['get','Layer'],
          'Divider', '#00FF00',
          'Road', '#ff0000',
          '#ff0000'
        ]);

        map.setPaintProperty('roads-3d', 'fill-extrusion-height', [
          'match', ['get','Layer'],
          'Divider', 0.50,
          'Road', 0.10,
          0.10
        ]);
      }

      // Drone opacity reset
      if (map.getLayer('drone')) {
        map.setPaintProperty('drone', 'raster-opacity', 1);
      }
    } catch(e){}

    /* DELETE DRAW FEATURES */
    try { if (draw) draw.deleteAll(); } catch(e){}

    /* CLOSE RIGHT PANEL IF OPEN */
    try {
      const rp = document.getElementById('rightPanel');
      if (rp && !rp.classList.contains('rightPanel-hidden')) {
        rp.classList.add('rightPanel-hidden');
      }
    } catch(e){}

    /* RESIZE MAP AFTER ANIMATION */
    setTimeout(() => {
      try { map.resize(); } catch(e){}
    }, 380);
  }
});


/* SEARCH logic */
window.searchMatches=[]; window.currentMatchIdx=0;
function getPlotPropertyValue(props){ return (props.PlotNo||props.Plotno||props.Plot_No||props.PLOTNO||props.Plot||'').toString(); }

function showMatch(index) {
  const matches = window.searchMatches||[];
  if (!matches || matches.length===0){ document.getElementById('searchRow').style.display='none'; updatePrimaryStat(currentField,{}); return; }
  index = ((index % matches.length)+matches.length)%matches.length;
  window.currentMatchIdx = index;
  const feat = matches[index];
  if (!feat) return;
  const props = feat.properties||{};
  if (props.Type_of_al||props.OwnerName||props.PlotNo) fillRightPanel('building', props);
  else if (props.Width||props.Layer) fillRightPanel('road', props);
  else if (props.Type||props.Location) fillRightPanel('street', props);
  else fillRightPanel('building', props);
  setSelectedFeature(feat);
  const foundCountEl = document.getElementById('s_total_found'); if (foundCountEl) foundCountEl.textContent = `${matches.length}`;
  document.getElementById('searchRow').style.display='flex';
  const resEl = document.getElementById('s_total_res'); if (resEl) resEl.style.display='none';
  let center=null;
  if (feat.geometry) {
    const g=feat.geometry;
    if (g.type==='Point') center=g.coordinates;
    else if (g.type==='Polygon') center=g.coordinates[0][0];
    else if (g.type==='MultiPolygon') center=g.coordinates[0][0][0];
    else if (g.type==='LineString') center=g.coordinates[Math.floor(g.coordinates.length/2)];
  }
  if (center) map.flyTo({ center, zoom:19, pitch:is3DView?60:0, bearing:is3DView?-17.6:0, duration:900 });
}

function performSearch(query) {
  if (!buildingsData){ log('No data for search'); return; }
  const q = (query||'').toString().trim().toUpperCase();
  if (q===''){ window.searchMatches=[]; window.currentMatchIdx=0; document.getElementById('searchRow').style.display='none'; const resEl=document.getElementById('s_total_res'); if(resEl) resEl.style.display=''; updateDashboard(buildingsData.features, currentField); clearSelectedFeature(); return;}
  const found = (buildingsData.features||[]).filter(f => (getPlotPropertyValue(f.properties)||'').toString().toUpperCase().includes(q));
  window.searchMatches = found; window.currentMatchIdx=0;
  const resEl=document.getElementById('s_total_res'); if(resEl) resEl.style.display='none';
  const foundCountEl=document.getElementById('s_total_found'); if(foundCountEl) foundCountEl.textContent = `${found.length}`;
  document.getElementById('searchRow').style.display='flex';
  if (found.length===0){ document.getElementById('infoTitle').textContent='No feature selected'; document.getElementById('infoTable').innerHTML=''; document.getElementById('infoTypeLine').textContent='No matches found'; clearSelectedFeature(); return;}
  showMatch(0);
}

document.getElementById('searchBox').addEventListener('keyup', function(e){ if(e.key==='Enter') performSearch(this.value); });
document.getElementById('searchBtn').addEventListener('click', () => performSearch(document.getElementById('searchBox').value));
let searchDebounce; document.getElementById('searchBox').addEventListener('input', function(){ clearTimeout(searchDebounce); searchDebounce=setTimeout(()=>performSearch(this.value),600); });
document.getElementById('prevMatchBtn').addEventListener('click', ()=>{ if(window.searchMatches&&window.searchMatches.length>0) showMatch(window.currentMatchIdx-1); });
document.getElementById('nextMatchBtn').addEventListener('click', ()=>{ if(window.searchMatches&&window.searchMatches.length>0) showMatch(window.currentMatchIdx+1); });

/* Chart */
const pieCtx = document.getElementById('pieChart').getContext('2d');
const pieChart = new Chart(pieCtx, {
  type:'pie',
  data:{ labels:[], datasets:[{ data:[], backgroundColor:[] }] },
  options:{ responsive:true, maintainAspectRatio:false, plugins:{ legend:{ position:'bottom', labels:{ color:'#111', padding:12, font:{ size:11 } } } } }
});

/* Dashboard helpers */
function updateDashboard(features, field) {
  if (!features) return;
  currentField = field;
  const counts = {};
  features.forEach(f => {
    let v = f.properties[field];
    if (field === 'Type_Trans') v = normalizeTransfer(v);
    if (field === 'Flood_Effe') v = normalizeFlood(v);
    if (v) counts[v] = (counts[v] || 0) + 1;
  });
  const labels = Object.keys(counts);
  const values = Object.values(counts);
  let colors = [];
  if (field === 'Type_of_al') colors = labels.map(l => propertyColors[l] || '#888');
  if (field === 'Flood_Effe') colors = labels.map(l => floodColors[l] || '#888');
  if (field === 'Type_Trans') colors = labels.map(l => transferTypeColors[l] || transferTypeColors['Other']);

  pieChart.data.labels = labels;
  pieChart.data.datasets[0].data = values;
  pieChart.data.datasets[0].backgroundColor = colors;
  pieChart.update();

  document.getElementById('s1').textContent = labels[0] ? `${labels[0]}: ${values[0]}` : '';
  document.getElementById('s2').textContent = labels[1] ? `${labels[1]}: ${values[1]}` : '';
  document.getElementById('s3').textContent = labels[2] ? `${labels[2]}: ${values[2]}` : '';
  document.getElementById('s4').textContent = labels[3] ? `${labels[3]}: ${values[3]}` : '';
  document.getElementById('s5').textContent = labels[4] ? `${labels[4]}: ${values[4]}` : '';

  updatePrimaryStat(field, counts);
}

function updatePrimaryStat(field, countsObj) {
  const counts = countsObj || {};
  const el = document.getElementById('s_total_res'); if (!el) return;
  if (field === 'Type_of_al') {
    if (Object.keys(counts).length === 0) {
      const total = (buildingsData && buildingsData.features) ? buildingsData.features.reduce((acc, f) => ((f.properties.Type_of_al||'').toString().toLowerCase()==='residential' ? acc+1 : acc), 0) : 0;
      el.textContent = `Residential: ${total}`; return;
    }
    const residential = counts['Residential'] || counts['residential'] || 0;
    el.textContent = `Residential: ${residential}`; return;
  }
  updatePrimaryStat('Type_of_al', {});
}

function updateTotalResidential() {
  const totalEl = document.getElementById('s_total_res');
  if (!totalEl || !buildingsData) return;
  const total = buildingsData.features.reduce((acc,f)=> ((f.properties.Type_of_al||'').toString().toLowerCase()==='residential' ? acc+1 : acc), 0);
  totalEl.textContent = `Residential: ${total}`;
}

/* UI Buttons */
document.getElementById('propertyBtn').addEventListener('click', ()=>{ if(!buildingsData) return; updateDashboard(buildingsData.features,'Type_of_al'); highlightBuildingsByField('Type_of_al'); });
document.getElementById('floodBtn').addEventListener('click', ()=>{ if(!buildingsData) return; updateDashboard(buildingsData.features,'Flood_Effe'); highlightBuildingsByField('Flood_Effe'); });
document.getElementById('transferTypeBtn').addEventListener('click', ()=>{ if(!buildingsData) return; updateDashboard(buildingsData.features,'Type_Trans'); highlightBuildingsByField('Type_Trans'); });

function highlightBuildingsByField(field) {
  if (!map.getLayer('buildings-3d')) return;
  if (!field) {
    map.setPaintProperty('buildings-3d','fill-extrusion-color', DEFAULT_BUILDING_COLOR);
    return;
  }
  const expr = ['match', ['get', field]];
  if (field === 'Type_of_al') {
    Object.keys(propertyColors).forEach(k => expr.push(k, propertyColors[k]));
    expr.push('#888888');
  } else if (field === 'Flood_Effe') {
    Object.keys(floodColors).forEach(k => expr.push(k, floodColors[k]));
    expr.push('#888888');
  } else if (field === 'Type_Trans') {
    Object.keys(transferTypeColors).forEach(k => expr.push(k, transferTypeColors[k]));
    expr.push('#888888');
  } else {
    expr.push(DEFAULT_BUILDING_COLOR);
  }
  map.setPaintProperty('buildings-3d','fill-extrusion-color', expr);
}

/* ----- VIEW TOGGLE handlers (top-center buttons) ----- */
document.getElementById('btn3D').addEventListener('click', () => {
  is3DView = true;
  try { map.easeTo({ pitch: 60, bearing: -17.6, duration: 800 }); } catch(e){}
  if (map.getLayer('buildings-3d')) {
    try { map.setPaintProperty('buildings-3d','fill-extrusion-height', buildHeightExpression()); } catch(e){}
  }
  document.getElementById('btn3D').disabled = true;
  document.getElementById('btn2D').disabled = false;
});
document.getElementById('btn2D').addEventListener('click', () => {
  is3DView = false;
  try { map.easeTo({ pitch: 0, bearing: 0, duration: 800 }); } catch(e){}
  if (map.getLayer('buildings-3d')) {
    try { map.setPaintProperty('buildings-3d','fill-extrusion-height', 0); } catch(e){}
  }
  document.getElementById('btn3D').disabled = false;
  document.getElementById('btn2D').disabled = true;
});

/* Reset */
document.getElementById('resetBtn').addEventListener('click', ()=> {
  map.easeTo({ center:[85.84,20.477], zoom:17, pitch:60, bearing:-17.6, duration:800 });
  if (map.getLayer('buildings-3d')) {
    map.setPaintProperty('buildings-3d','fill-extrusion-color', DEFAULT_BUILDING_COLOR);
    map.setPaintProperty('buildings-3d','fill-extrusion-height', buildHeightExpression());
  }
  if (map.getLayer('roads-3d')) {
    map.setPaintProperty('roads-3d','fill-extrusion-color', [
      'match',
      ['get','Layer'],
      'Divider', '#00FF00',
      'Road', '#ff0000',
      '#ff0000'
    ]);
    map.setPaintProperty('roads-3d','fill-extrusion-height', [
      'match',
      ['get','Layer'],
      'Divider', 0.50,
      'Road', 0.10,
      0.10
    ]);
  }
  try { if (map.getLayer('drone')) map.setPaintProperty('drone','raster-opacity',1); } catch(e){}
  updateDashboard(buildingsData.features, 'Type_of_al');
  document.getElementById('searchBox').value=''; document.getElementById('searchRow').style.display='none'; document.getElementById('s_total_res').style.display='';
  clearSelectedFeature();
  try { if(draw) draw.deleteAll(); } catch(e){}
});

/* Layer toggles are hooked to the top-centre UI */
document.getElementById('btnLayers').addEventListener('click', ()=>{ const el=document.getElementById('layerList'); el.style.display = el.style.display==='block' ? 'none' : 'block'; });
document.getElementById('toggleBuildings').addEventListener('change', function(){ const v=this.checked?'visible':'none'; if(map.getLayer('buildings-3d')) map.setLayoutProperty('buildings-3d','visibility',v); if(v==='none'){ clearSelectedFeature(); document.getElementById('searchRow').style.display='none'; document.getElementById('s_total_res').style.display=''; } });
document.getElementById('toggleRoads').addEventListener('change', function(){ const v=this.checked?'visible':'none'; if(map.getLayer('roads-3d')) map.setLayoutProperty('roads-3d','visibility',v); });
document.getElementById('toggleStreet').addEventListener('change', function(){ const v=this.checked?'visible':'none'; if(map.getLayer('street-point')) map.setLayoutProperty('street-point','visibility',v); });

document.getElementById('toggleDrone').addEventListener('change', function(){
  const checkbox = this;
  if (!map.getLayer('drone')) { alert('Drone raster not available (tile URL may be unreachable).'); checkbox.checked = false; return; }
  const vis = checkbox.checked ? 'visible' : 'none';
  map.setLayoutProperty('drone','visibility', vis);
  if (checkbox.checked) {
    try { map.setPaintProperty('drone','raster-opacity', 1); } catch (e) { }
    moveDroneUnderVectors();
  }
});

/* keep data in sync if source updates */
map.on('sourcedata', (e)=> {
  if (e.sourceId==='buildings' && e.isSourceLoaded) {
    try { const src=map.getSource('buildings'); if(src && src._data){ buildingsData=src._data; updateTotalResidential(); updatePrimaryStat(currentField, {}); } } catch(err){}
  }
});

/* --- STREET VIEW: new functions & event handlers --- */

const GOOGLE_API_KEY = 'AIzaSyBwJnprg61M8EWryIBQxT1_f3qxueLfQic'; // your API key

// Simple loader check (Maps JS is loaded below with script tag)
// openStreetViewAt(lat, lng) ‚Äî tries to show a panorama close to given coords
function openStreetViewAt(requestLat, requestLng) {
  const panel = document.getElementById('streetviewPanel');
  const panoDiv = document.getElementById('pano');
  const msgEl = document.getElementById('streetviewMsg');
  panoDiv.style.display = 'block';
  msgEl.style.display = 'none';
  panel.style.display = 'block';

  if (typeof google === 'undefined' || !google.maps || !google.maps.StreetViewService) {
    msgEl.style.display = 'block';
    msgEl.textContent = 'Google Maps API not loaded yet. Please check your API key or internet connection.';
    panoDiv.style.display = 'none';
    return;
  }

  const svService = new google.maps.StreetViewService();
  // radius in meters to search
  const radii = [50, 200];
   (function tryRadius(i) {
    if (i >= radii.length) {
      msgEl.style.display = 'block';
      msgEl.textContent = 'No Street View panorama found near this location.';
      panoDiv.style.display = 'none';
      return;
    }
    const RADIUS = radii[i];

   svService.getPanorama({ location: { lat: requestLat, lng: requestLng }, radius: RADIUS }, (data, status) => {
      if (status === google.maps.StreetViewStatus.OK && data && data.location) {
	  
        // compute heading so panorama faces the original requested point
        // panorama location:
        const panoLatLng = data.location.latLng || data.location.location || null;
        const panoLat = (panoLatLng && panoLatLng.lat) ? panoLatLng.lat() : (data.location.latLng ? data.location.latLng.lat() : (data.location.lat || null));
        const panoLng = (panoLatLng && panoLatLng.lng) ? panoLatLng.lng() : (data.location.latLng ? data.location.latLng.lng() : (data.location.lng || null));

        // compute heading from pano position -> requested point
        let heading = 0;
        try {
          // turf expects [lng, lat]
          const bearing = turf.bearing(turf.point([panoLng, panoLat]), turf.point([requestLng, requestLat]));
          // normalize into 0..360
          heading = ((bearing % 360) + 360) % 360;
        } catch (err) {
          heading = 0;
        }

        const pov = { heading: heading, pitch: 0, zoom: 1 };
        // Create or reuse panorama. Prefer setting 'position' to pano location for best alignment.
        try {
          if (!window._cda_panorama) {
            window._cda_panorama = new google.maps.StreetViewPanorama(document.getElementById('pano'), {
              position: { lat: panoLat, lng: panoLng },
              pov: pov,
              visible: true
            });
          } else {
            // prefer setPosition + setPov for smooth transition
            try {
              window._cda_panorama.setPosition({ lat: panoLat, lng: panoLng });
              window._cda_panorama.setPov(pov);
              window._cda_panorama.setVisible(true);
            } catch (err) {
              // fallback to setPano if needed
              if (data.location && data.location.pano) window._cda_panorama.setPano(data.location.pano);
              window._cda_panorama.setPov(pov);
              window._cda_panorama.setVisible(true);
            }
          }

          // optionally display a small caption with pano distance/coords
          try {
            const distMeters = turf.distance(turf.point([requestLng, requestLat]), turf.point([panoLng, panoLat]), { units: 'meters' });
            msgEl.style.display = 'block';
            msgEl.textContent = `Panorama ~${Math.round(distMeters)} m from requested point. Use CTRL+click or right-click to open street view.`;
            // hide msg after 3s
            setTimeout(()=> { msgEl.style.display = 'none'; }, 3000);
          } catch (err) {
            // ignore distance compute errors
          }

        } catch (err) {
          msgEl.style.display = 'block';
          msgEl.textContent = 'Failed to show Street View: ' + (err && err.message ? err.message : err);
          panoDiv.style.display = 'none';
        }
      } else {
        // try next radius
        tryRadius(i + 1);
      }
    });
  })(0);
}

// Close Street View panel
function closeStreetView() {
  const panel = document.getElementById('streetviewPanel');
  panel.style.display = 'none';
  try { if (window._cda_panorama) window._cda_panorama.setVisible(false); } catch(e){}
}

// Hook UI: toolbar button opens Street View at current map center
document.getElementById('btnStreetView').addEventListener('click', () => {
  const c = map.getCenter();
  openStreetViewAt(c.lat, c.lng);
});

// Hook UI: panel close button
document.getElementById('streetviewCloseBtn').addEventListener('click', closeStreetView);

// Hook map contextmenu (right-click) to open Street View at click location
map.on('contextmenu', (e) => {
  try {
    const ll = e.lngLat;
    openStreetViewAt(ll.lat, ll.lng);
  } catch (err) { console.warn('Street View open failed at contextmenu:', err); }
});

// Also allow CTRL+click to open Street View (some users prefer keyboard)
// unify click behavior: if ctrl/meta pressed open streetview. This avoids multiple conflicting handlers.
map.on('click', (e) => {
  // if ctrl/meta pressed, open street view (and *do not* block other logic)
  if (e.originalEvent && (e.originalEvent.ctrlKey || e.originalEvent.metaKey)) {
    try {
      openStreetViewAt(e.lngLat.lat, e.lngLat.lng);
    } catch (err) {
      console.warn('openStreetViewAt failed:', err);
    }
    // allow other click handlers to continue (they run independently).
  }
});
/* ===== FULL EDGE & CORNER RESIZE + DRAG (pointer-based) FOR STREET VIEW PANEL =====
   Replace your old setupStreetViewDragResize() IIFE with this block.
*/
(function setupStreetViewEdgeResize() {
  const panel = document.getElementById("streetviewPanel");
  const header = document.getElementById("streetviewHeader");
  if (!panel || !header) return;

  panel.style.position = "absolute";
  panel.style.touchAction = "none";
  const HIT = 10; // px from edge considered "grabbable"
  const MIN_W = 240;
  const MIN_H = 160;
  const PADDING = 8;
  let mode = null; // 'drag' | 'resize-left' | 'resize-right' | 'resize-top' | 'resize-bottom' | 'resize-top-left' | ...
  let activePointer = null;
  let start = { x: 0, y: 0, left: 0, top: 0, w: 0, h: 0 };

  // Utility clamp
  function clamp(left, top, w, h) {
    const vw = Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0);
    const vh = Math.max(document.documentElement.clientHeight || 0, window.innerHeight || 0);
    left = Math.min(Math.max(PADDING, left), vw - w - PADDING);
    top  = Math.min(Math.max(PADDING + 72, top), vh - h - PADDING); // keep below header area
    return { left, top };
  }

  // Determine hit region (edges/corners) for a point inside panel rect
  function hitTest(ev) {
    const rect = panel.getBoundingClientRect();
    const x = ev.clientX - rect.left;
    const y = ev.clientY - rect.top;
    const right = rect.width - x;
    const bottom = rect.height - y;
    const leftEdge = x <= HIT;
    const rightEdge = right <= HIT;
    const topEdge = y <= HIT;
    const bottomEdge = bottom <= HIT;

    if (topEdge && leftEdge) return 'resize-top-left';
    if (topEdge && rightEdge) return 'resize-top-right';
    if (bottomEdge && leftEdge) return 'resize-bottom-left';
    if (bottomEdge && rightEdge) return 'resize-bottom-right';
    if (leftEdge) return 'resize-left';
    if (rightEdge) return 'resize-right';
    if (topEdge) return 'resize-top';
    if (bottomEdge) return 'resize-bottom';
    return null;
  }

  // Update pointer cursor based on hover region
  function updateCursor(ev) {
    if (mode) return; // during active action keep cursor as-is
    const hit = hitTest(ev);
    let cur = '';
    if (!hit) cur = '';
    else if (hit.indexOf('left') >= 0 && hit.indexOf('top') >= 0) cur = 'nwse-resize';
    else if (hit.indexOf('right') >= 0 && hit.indexOf('bottom') >= 0) cur = 'nwse-resize';
    else if (hit.indexOf('right') >= 0 && hit.indexOf('top') >= 0) cur = 'nesw-resize';
    else if (hit.indexOf('left') >= 0 && hit.indexOf('bottom') >= 0) cur = 'nesw-resize';
    else if (hit.indexOf('left') >= 0 || hit === 'resize-right') cur = 'ew-resize';
    else if (hit.indexOf('top') >= 0 || hit === 'resize-bottom') cur = 'ns-resize';
    else cur = 'move';
    panel.style.cursor = cur;
    header.style.cursor = 'move';
  }

  // Pointerdown: start drag on header, or start resize on panel edges
// Pointerdown: start drag on header, or start resize on panel edges
panel.addEventListener('pointerdown', (ev) => {
  // Left-button only
  if (ev.button !== 0) return;

  // If user clicked the close button (or any child of it), do NOT start drag/resize
  // ‚Äî allow the button to receive the event normally.
  if (ev.target && ev.target.closest && ev.target.closest('#streetviewCloseBtn')) {
    return;
  }

  activePointer = ev.pointerId;
  try { panel.setPointerCapture(activePointer); } catch(e){ /* some browsers may throw */ }

  // If pointer is on header -> drag
  const hdrRect = header.getBoundingClientRect();
  if (ev.clientX >= hdrRect.left && ev.clientX <= hdrRect.right && ev.clientY >= hdrRect.top && ev.clientY <= hdrRect.bottom) {
    mode = 'drag';
  } else {
    // check edge hit
    const h = hitTest(ev);
    if (h) mode = h;
    else {
      // not on header or edges ‚Äî nothing to do
      mode = null;
      try { panel.releasePointerCapture(activePointer); } catch(e){}
      activePointer = null;
      return;
    }
  }

  const rect = panel.getBoundingClientRect();
  start.x = ev.clientX; start.y = ev.clientY;
  start.left = rect.left; start.top = rect.top; start.w = rect.width; start.h = rect.height;
  document.body.style.userSelect = 'none';
});


  // Pointermove: either change cursor (hover) or perform active drag/resize
  panel.addEventListener('pointermove', (ev) => {
    ev.preventDefault();
    if (!activePointer) {
      updateCursor(ev);
      return;
    }
    if (ev.pointerId !== activePointer) return;

    const dx = ev.clientX - start.x;
    const dy = ev.clientY - start.y;

    let newLeft = start.left;
    let newTop = start.top;
    let newW = start.w;
    let newH = start.h;

    if (mode === 'drag') {
      newLeft = Math.round(start.left + dx);
      newTop  = Math.round(start.top + dy);
      const cl = clamp(newLeft, newTop, newW, newH);
      panel.style.left = cl.left + 'px';
      panel.style.top  = cl.top  + 'px';
      panel.style.right = 'auto';
    } else if (mode && mode.startsWith('resize')) {
      // handle each resize direction
      if (mode.indexOf('left') >= 0) {
        newW = Math.max(MIN_W, Math.round(start.w - dx));
        newLeft = Math.round(start.left + dx);
      }
      if (mode.indexOf('right') >= 0) {
        newW = Math.max(MIN_W, Math.round(start.w + dx));
      }
      if (mode.indexOf('top') >= 0) {
        newH = Math.max(MIN_H, Math.round(start.h - dy));
        newTop = Math.round(start.top + dy);
      }
      if (mode.indexOf('bottom') >= 0) {
        newH = Math.max(MIN_H, Math.round(start.h + dy));
      }

      // clamp width/height so panel stays inside viewport
      const vw = Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0);
      const vh = Math.max(document.documentElement.clientHeight || 0, window.innerHeight || 0);

      // enforce right/bottom bounds
      if (newLeft + newW > vw - PADDING) newW = Math.max(MIN_W, vw - PADDING - newLeft);
      if (newTop + newH > vh - PADDING) newH = Math.max(MIN_H, vh - PADDING - newTop);

      // if left edge moved past bounds, clamp it
      if (newLeft < PADDING) {
        const diff = PADDING - newLeft;
        newLeft = PADDING;
        newW = Math.max(MIN_W, newW - diff);
      }
      if (newTop < PADDING + 72) {
        const diff = (PADDING + 72) - newTop;
        newTop = PADDING + 72;
        newH = Math.max(MIN_H, newH - diff);
      }

      // apply
      panel.style.left = newLeft + 'px';
      panel.style.top  = newTop + 'px';
      panel.style.width  = newW + 'px';
      panel.style.height = newH + 'px';
      panel.style.right = 'auto';

      // notify Street View to redraw (throttled)
      if (window._cda_panorama && typeof google !== 'undefined' && google && google.maps && google.maps.event && typeof google.maps.event.trigger === 'function') {
        if (setupStreetViewEdgeResize._t) clearTimeout(setupStreetViewEdgeResize._t);
        setupStreetViewEdgeResize._t = setTimeout(() => {
          try { google.maps.event.trigger(window._cda_panorama, 'resize'); } catch(e){/*ignore*/ }
        }, 100);
      }
    }
  });

  // pointerup / cancel: finish action
  function endAction(ev) {
    if (!activePointer || ev.pointerId !== activePointer) return;
    activePointer = null;
    try { panel.releasePointerCapture(ev.pointerId); } catch(e){ }
    mode = null;
    document.body.style.userSelect = 'auto';
    // final resize trigger
    if (window._cda_panorama && typeof google !== 'undefined' && google && google.maps && google.maps.event && typeof google.maps.event.trigger === 'function') {
      try { google.maps.event.trigger(window._cda_panorama, 'resize'); } catch(e){/*ignore*/ }
    }
  }
  panel.addEventListener('pointerup', endAction);
  panel.addEventListener('pointercancel', endAction);

  // also update cursor when mouse moves over panel (not dragging)
  panel.addEventListener('mousemove', updateCursor);
  panel.addEventListener('mouseleave', (ev) => {
    if (!activePointer) panel.style.cursor = '';
  });

  // If panel visibility changes, ensure it's positioned inside viewport
  const mo = new MutationObserver(() => {
    if (panel.style.display !== 'none') {
      const rect = panel.getBoundingClientRect();
      if (!panel.style.left && !panel.style.top) {
        const cl = clamp(rect.left || PADDING, rect.top || (PADDING + 72), rect.width || 520, rect.height || 420);
        panel.style.left = cl.left + 'px';
        panel.style.top = cl.top + 'px';
      }
      // ensure pano div fills
      const pano = document.getElementById('pano');
      if (pano) { pano.style.width = '100%'; pano.style.height = '100%'; }
      // trigger a resize of panorama if already present
      if (window._cda_panorama && typeof google !== 'undefined' && google && google.maps && google.maps.event) {
        setTimeout(()=> { try { google.maps.event.trigger(window._cda_panorama,'resize'); } catch(e){} }, 80);
      }
    }
  });
  mo.observe(panel, { attributes: true, attributeFilter: ['style'] });

})();




/* =========================
   MEASURE + EDITABLE POINTS
   ========================= */

/* State for measure tool */
let measureActive = false;
let measureMode = 'distance'; // 'distance' or 'area'
let markers = [];             // Maplibre Markers (draggable)
let coords = [];              // coordinates array [ [lng,lat], ... ]
const tempSourceId = 'measure-temp';
const lineLayerId = 'measure-line';
const polyLayerId = 'measure-fill';
const pointsLayerId = 'measure-points';

/* Ensure measure source & layers */
function ensureMeasureLayers(){
  if (map.getSource(tempSourceId)) return;
  map.addSource(tempSourceId, { type: 'geojson', data: { type:'FeatureCollection', features: [] } });

  map.addLayer({
    id: lineLayerId,
    type: 'line',
    source: tempSourceId,
    paint: { 'line-color': '#ff7a00', 'line-width': 4, 'line-dasharray':[2,2] },
    layout: { 'visibility':'visible' }
  });

  map.addLayer({
    id: polyLayerId,
    type: 'fill',
    source: tempSourceId,
    paint: { 'fill-color':'#ffb780', 'fill-opacity': 0.35 },
    layout: { 'visibility':'visible' }
  });

  map.addLayer({
    id: pointsLayerId,
    type: 'circle',
    source: tempSourceId,
    paint: { 'circle-radius':6, 'circle-color':'#ff7a00', 'circle-stroke-color':'#fff', 'circle-stroke-width':2 }
  });
}

/* update geojson for layers (line/polygon/points) */
function updateMeasureGeoJSON(){
  const src = map.getSource(tempSourceId);
  if (!src) return;
  const features = [];
  if (coords.length > 0) {
    features.push({ type:'Feature', geometry: { type:'MultiPoint', coordinates: coords }, properties:{} });
    if (measureMode === 'distance') {
      if (coords.length >= 2) features.push({ type:'Feature', geometry: { type:'LineString', coordinates: coords }, properties:{} });
    } else {
      if (coords.length >= 3) {
        const polyCoords = coords.slice();
        if (polyCoords.length && (polyCoords[0][0] !== polyCoords[polyCoords.length-1][0] || polyCoords[0][1] !== polyCoords[polyCoords.length-1][1])) {
          polyCoords.push(polyCoords[0]);
        }
        features.push({ type:'Feature', geometry: { type:'Polygon', coordinates: [ polyCoords ] }, properties:{} });
      }
    }
  }
  src.setData({ type:'FeatureCollection', features });
}

/* create draggable marker at coordinate */
function createDraggableMarker(lnglat, idx){
  const el = document.createElement('div');
  el.style.width = '14px';
  el.style.height = '14px';
  el.style.borderRadius = '50%';
  el.style.background = '#ff7a00';
  el.style.border = '2px solid #fff';
  el.style.boxShadow = '0 2px 6px rgba(0,0,0,0.3)';
  el.style.cursor = 'grab';

  const marker = new maplibregl.Marker({ element: el, draggable: true })
    .setLngLat(lnglat)
    .addTo(map);

  marker.getElement().addEventListener('click', (ev) => {
    ev.stopPropagation();
    clearSelectedMarkerStyles();
    marker.getElement().style.boxShadow = '0 0 0 3px rgba(43,108,176,0.25)';
    marker.__selected = true;
  });

  marker.on('dragstart', () => {
    clearSelectedMarkerStyles();
  });

  marker.on('dragend', () => {
    const ll = marker.getLngLat();
    const findIdx = markers.indexOf(marker);
    if (findIdx >= 0) {
      coords[findIdx] = [ll.lng, ll.lat];
      updateMeasureGeoJSON();
      updateMeasurementDisplay();
    }
  });

  return marker;
}

function clearSelectedMarkerStyles(){
  markers.forEach(m => {
    if (m && m.getElement) {
      m.getElement().style.boxShadow = '0 2px 6px rgba(0,0,0,0.3)';
      m.__selected = false;
    }
  });
}

/* Add point at click */
function addMeasurePoint(lnglat){
  const marker = createDraggableMarker(lnglat);
  markers.push(marker);
  coords.push([lnglat.lng || lnglat[0], lnglat.lat || lnglat[1]]);
  ensureMeasureLayers();
  updateMeasureGeoJSON();
  updateMeasurementDisplay();
}

/* Remove last point (undo) */
function undoPoint(){
  if (markers.length === 0) return;
  const m = markers.pop();
  try { m.remove(); } catch(e){}
  coords.pop();
  updateMeasureGeoJSON();
  updateMeasurementDisplay();
}

/* Clear all points */
function clearAllPoints(){
  while(markers.length) {
    const m = markers.pop();
    try { m.remove(); } catch(e){}
  }
  coords = [];
  try { if (map.getSource(tempSourceId)) map.getSource(tempSourceId).setData({ type:'FeatureCollection', features: [] }); } catch(e){}
  updateMeasurementDisplay();
}

/* Finish measurement */
function finishMeasurement(){
  measureActive = false;
  document.getElementById('btnMeasure').classList.remove('active');
  document.getElementById('measurePanel').style.display = 'none';
  map.getCanvas().style.cursor = '';
}

/* Unit conversion helpers */
function formatDistanceMetersTo(unit, meters){
  if (unit === 'meters') return `${meters.toFixed(2)} m`;
  if (unit === 'kilometers') return `${(meters/1000).toFixed(3)} km`;
  if (unit === 'feet') return `${(meters * 3.2808399).toFixed(2)} ft`;
  if (unit === 'miles') return `${(meters * 0.000621371).toFixed(3)} mi`;
  if (unit === 'auto-dist') {
    if (meters < 1000) return `${Math.round(meters)} m`;
    return `${(meters/1000).toFixed(3)} km`;
  }
  return `${meters.toFixed(2)} m`;
}

function formatAreaSqMetersTo(unit, sqm){
  if (unit === 'sqft') return `${(sqm * 10.76391041671).toFixed(2)} sqft`;
  if (unit === 'sqm') return `${sqm.toFixed(2)} m¬≤`;
  if (unit === 'sqkm') return `${(sqm/1e6).toFixed(3)} km¬≤`;
  if (unit === 'acres') return `${(sqm * 0.000247105381).toFixed(3)} acres`;
  if (unit === 'hectares') return `${(sqm/10000).toFixed(3)} ha`;
  return `${sqm.toFixed(2)} m¬≤`;
}

function updateMeasurementDisplay(){
  const resultEl = document.getElementById('measureResult');
  if (!resultEl) return;

  if (coords.length === 0) { resultEl.textContent = 'No measurement yet'; return; }

  const unitDist = document.getElementById('unitSelect').value || 'auto-dist';
  const unitArea = document.getElementById('areaUnitSelect').value || 'sqft';

  if (measureMode === 'distance') {
    if (coords.length < 2) {
      resultEl.textContent = 'Not enough points to measure distance';
      return;
    }
    const line = turf.lineString(coords);
    const meters = turf.length(line, { units:'kilometers' }) * 1000;
    resultEl.textContent = `Distance: ${formatDistanceMetersTo(unitDist, meters)}`;
  } else {
    if (coords.length < 3) {
      resultEl.textContent = 'Not enough points to measure area';
      return;
    }
    const polyCoords = coords.slice();
    if (polyCoords[0][0] !== polyCoords[polyCoords.length-1][0] || polyCoords[0][1] !== polyCoords[polyCoords.length-1][1]) polyCoords.push(polyCoords[0]);
    const poly = turf.polygon([polyCoords]);
    const sqm = turf.area(poly);
    resultEl.textContent = `Area: ${formatAreaSqMetersTo(unitArea, sqm)}`;
  }
}

/* Toggle measure mode on/off */
function toggleMeasure(){
  measureActive = !measureActive;
  const panel = document.getElementById('measurePanel');
  if (measureActive) {
    panel.style.display = 'block';
    map.getCanvas().style.cursor = 'crosshair';
    document.getElementById('btnMeasure').classList.add('active');
    ensureMeasureLayers();
  } else {
    panel.style.display = 'none';
    map.getCanvas().style.cursor = '';
    document.getElementById('btnMeasure').classList.remove('active');
  }
}

/* Map click: when measureActive add point; when not active, other click handler runs (it returns early if measureActive) */
map.on('click', (e) => {
  if (measureActive) {
    addMeasurePoint(e.lngLat);
    return;
  }
});

/* Keyboard support */
document.addEventListener('keydown', (ev) => {
  if (ev.key === 'Escape') {
    if (measureActive) {
      finishMeasurement();
    }
  }
  if (ev.key === 'Delete' || ev.key === 'Backspace') {
    const selIndex = markers.findIndex(m => m.__selected === true);
    if (selIndex >= 0) {
      const m = markers.splice(selIndex,1)[0];
      try { m.remove(); } catch(e){}
      coords.splice(selIndex,1);
      updateMeasureGeoJSON();
      updateMeasurementDisplay();
    }
  }
});

/* UI hooks */
document.getElementById('btnMeasure').addEventListener('click', () => toggleMeasure());
document.getElementById('tool-line').addEventListener('click', function(){
  measureMode = 'distance';
  this.classList.add('active');
  document.getElementById('tool-polygon').classList.remove('active');
  updateMeasurementDisplay();
});
document.getElementById('tool-polygon').addEventListener('click', function(){
  measureMode = 'area';
  this.classList.add('active');
  document.getElementById('tool-line').classList.remove('active');
  updateMeasurementDisplay();
});
document.getElementById('undoBtn').addEventListener('click', () => undoPoint());
document.getElementById('clearBtn').addEventListener('click', () => { clearAllPoints(); });
document.getElementById('finishBtn').addEventListener('click', () => { finishMeasurement(); });
document.getElementById('btn-undo').addEventListener('click', () => undoPoint());
document.getElementById('unitSelect').addEventListener('change', () => updateMeasurementDisplay());
document.getElementById('areaUnitSelect').addEventListener('change', () => updateMeasurementDisplay());

/* Export button hook: calls existing exportMapPNG if present */
document.getElementById('btnExport').addEventListener('click', () => {
  if (typeof exportMapPNG === 'function') exportMapPNG();
  else alert('Export function not found.');
});

/* ensure measure layers exist on load so toggling is smooth */
map.on('load', () => {
  if (!map.getSource(tempSourceId)) {
    map.addSource(tempSourceId, { type:'geojson', data: { type:'FeatureCollection', features: [] } });
    map.addLayer({ id: lineLayerId, type: 'line', source: tempSourceId, paint:{ 'line-color':'#ff7a00', 'line-width':4, 'line-dasharray':[2,2] } });
    map.addLayer({ id: polyLayerId, type:'fill', source: tempSourceId, paint:{ 'fill-color':'#ffb780','fill-opacity':0.35 } });
    map.addLayer({ id: pointsLayerId, type:'circle', source: tempSourceId, paint:{ 'circle-radius':6,'circle-color':'#ff7a00','circle-stroke-color':'#fff','circle-stroke-width':2 } });
  }
});

/* Clean-up note */
map.on('remove', function() {
  try {
    if (map.getLayer(lineLayerId)) map.removeLayer(lineLayerId);
    if (map.getLayer(polyLayerId)) map.removeLayer(polyLayerId);
    if (map.getLayer(pointsLayerId)) map.removeLayer(pointsLayerId);
    if (map.getSource(tempSourceId)) map.removeSource(tempSourceId);
  } catch(e){}
});

/* =========================
   KEEP THE ORIGINAL EXPORT FUNCTION (if present)
   =========================
   In your original file exportMapPNG() is defined below ‚Äî left unchanged.
   If you pasted this file over your original it will find and call the same function.
*/

function exportMapPNG() {
  try {
    map.once('idle', function() {
      try {
        const mapCanvas = map.getCanvas();
		const scale = 0.75;
        const rightPanel = document.getElementById('rightPanel');
        const infoTable = document.getElementById('infoTable');
        const infoTitleEl = document.getElementById('infoTitle');

        const infoWidth = 280;
        const padding = 18;
        const outerBorderGap = 6;
        const innerBorderGap = 6;
		
        const exportCanvas = document.createElement('canvas');
        exportCanvas.width = mapCanvas.width + infoWidth + outerBorderGap * 2;
        exportCanvas.height = mapCanvas.height + outerBorderGap * 2;
        const ctx = exportCanvas.getContext('2d');

        // white outer background + outer border
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, exportCanvas.width, exportCanvas.height);
        ctx.strokeStyle = '#d1d5db';
        ctx.lineWidth = 2;
        ctx.strokeRect(outerBorderGap / 2, outerBorderGap / 2, exportCanvas.width - outerBorderGap, exportCanvas.height - outerBorderGap);

        // draw map area (offset for outer border)
        ctx.drawImage(mapCanvas, outerBorderGap, outerBorderGap);

        // info panel position & dimensions
        const infoX = outerBorderGap + mapCanvas.width;
        const infoY = outerBorderGap;
        const infoH = exportCanvas.height - outerBorderGap * 2;
        const infoW = infoWidth;

        // info panel white background
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(infoX, infoY, infoW, infoH);

        // inner border around info panel
        ctx.strokeStyle = '#e6eaf0';
        ctx.lineWidth = 2;
        ctx.strokeRect(infoX + innerBorderGap/2, infoY + innerBorderGap/2, infoW - innerBorderGap, infoH - innerBorderGap);

        // colors & fonts
        const labelColor = '#0b63b8'; // blue for labels
        const valueColor = '#0b0b0b'; // black for values
        const footerBg = '#b71c1c';
        const footerTextColor = '#ffffff';

        // Collect table rows
        const tableRows = [];
        if (infoTable) {
          const rows = infoTable.querySelectorAll('tr');
          rows.forEach(r => {
            const keyEl = r.querySelector('td.key');
            const valEl = r.querySelector('td.value');
            const keyText = keyEl ? keyEl.textContent.trim() : '';
            const valText = valEl ? valEl.textContent.trim() : '';
            if (keyText || valText) tableRows.push({ key: keyText, value: valText });
          });
        }

        // Owner and sector extraction (owner used as top heading)
        let ownerName = '';
        if (infoTable) {
          const rows = infoTable.querySelectorAll('tr');
          rows.forEach(r => {
            const k = r.querySelector('td.key');
            const v = r.querySelector('td.value');
            if (k && v && !ownerName) {
              if (k.textContent.toLowerCase().includes('owner')) ownerName = v.textContent.trim();
            }
          });
        }
        if (!ownerName && infoTitleEl && infoTitleEl.textContent) ownerName = infoTitleEl.textContent.trim();
        if (!ownerName) ownerName = 'Owner: N/A';

        let sectorName = 'Sector 6';
        const siteHdr = document.querySelector('.site-header');
        if (siteHdr) {
          const txt = siteHdr.textContent || '';
          const m = txt.match(/Sector\s*\d+/i);
          if (m) sectorName = m[0].trim();
        }

        // layout reserved sizes
        const topReserved = 26 + 22 + 14; // owner + sector + divider
        const footerHeight = 46;
        const availableHeight = infoH - padding*2 - topReserved - footerHeight - 8;

        // dynamic font sizing (start at 13px, down to 10px)
        let fontSize = 16;
        function estimateNeededHeight(fs) {
          const lh = Math.round(fs * 1.25);
          ctx.font = `${fs}px Arial`;
          let yNeeded = 0;
          tableRows.forEach(row => {
            // try label+value on same line
            const combined = `${row.key}: ${row.value}`;
            const combW = ctx.measureText(combined).width;
            if (combW <= (infoW - padding*2)) {
              // label+value on one line
              yNeeded += lh;
            } else {
              // label line + wrapped value lines
              yNeeded += lh; // label
              // wrap value
              const words = (row.value||'').split(' ');
              let cur = '';
              let lines = 0;
              words.forEach(w => {
                const test = cur ? (cur + ' ' + w) : w;
                if (ctx.measureText(test).width > (infoW - padding*2 - 10)) {
                  lines++;
                  cur = w;
                } else {
                  cur = test;
                }
              });
              if (cur) lines++;
              yNeeded += lines * lh;
            }
            yNeeded += 6; // spacing after row
          });
          return yNeeded;
        }

        while (fontSize >= 10) {
          const need = estimateNeededHeight(fontSize);
          if (need <= availableHeight) break;
          fontSize--;
        }
        const labelFont = `bold ${fontSize}px Arial`;
        const valueFont = `${fontSize}px Arial`;
        const ownerFont = `bold ${Math.max(16, fontSize+3)}px Arial`;
        const sectorFont = `600 ${Math.max(12, fontSize)}px Arial`;
        const lineHeight = Math.round(fontSize * 1.25);

        // draw owner & sector at top
        let y = infoY + padding + 6;
        ctx.fillStyle = '#0b0b0b';
        ctx.font = ownerFont;
        ctx.fillText(ownerName, infoX + padding, y);
        y += Math.max(16, fontSize+3) + 6;

        ctx.fillStyle = '#2f6fb0';
        ctx.font = sectorFont;
        ctx.fillText(sectorName, infoX + padding, y);
        y += 14;

        // divider
        ctx.strokeStyle = 'rgba(0,0,0,0.08)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(infoX + padding, y);
        ctx.lineTo(infoX + infoW - padding, y);
        ctx.stroke();
        y += 12;

        // render each row: try "label: value" same line if fit, else label then wrapped value
        ctx.textBaseline = 'top';
        for (let i=0;i<tableRows.length;i++) {
          const row = tableRows[i];
          const keyText = row.key || '';
          const valText = row.value || 'N/A';
          const combined = `${keyText}: ${valText}`;

          ctx.font = `${fontSize}px Arial`;
          const combinedWidth = ctx.measureText(combined).width;

          if (combinedWidth <= (infoW - padding*2)) {
            // draw both on single line
            // label
            ctx.font = labelFont;
            ctx.fillStyle = labelColor;
            ctx.fillText(keyText + ':', infoX + padding, y);
            // value on same line after label width
            const keyW = ctx.measureText(keyText + ':').width + 6;
            ctx.font = valueFont;
            ctx.fillStyle = valueColor;
            ctx.fillText(valText, infoX + padding + keyW, y);
            y += lineHeight + 6;
          } else {
            // draw label on its line
            ctx.font = labelFont;
            ctx.fillStyle = labelColor;
            ctx.fillText(keyText + ':', infoX + padding, y);
            y += Math.round(fontSize * 0.9);

            // wrap value with indent
            ctx.font = valueFont;
            ctx.fillStyle = valueColor;
            const maxW = infoW - padding*2 - 10; // indent for wrapped lines
            const words = valText.split(' ');
            let cur = '';
            let firstLine = true;
            let vY = y;
            for (let w of words) {
              const test = cur ? (cur + ' ' + w) : w;
              if (ctx.measureText(test).width > maxW) {
                // draw current
                ctx.fillText(cur, infoX + padding + (firstLine ? 0 : 10), vY);
                vY += lineHeight;
                cur = w;
                firstLine = false;
              } else {
                cur = test;
              }
            }
            if (cur) {
              ctx.fillText(cur, infoX + padding + (firstLine ? 0 : 10), vY);
              vY += lineHeight;
            }
            y = vY + 6;
          }

          // safety: if y exceeds allowed area break (shouldn't with font-sizing)
          if (y > infoY + infoH - footerHeight - 12) {
            // add truncation marker and break
            ctx.fillStyle = valueColor;
            ctx.font = valueFont;
            ctx.fillText('... (more)', infoX + padding, y);
            y += lineHeight;
            break;
          }
        }

// footer bar (THIS IS ONLY IN EXPORT - user wanted export footer kept)
ctx.fillStyle = footerBg;
ctx.fillRect(infoX, infoY + infoH - footerHeight, infoW, footerHeight);

// footer text centered
ctx.fillStyle = footerTextColor;
ctx.font = 'bold 14px Arial';

const footerText = 'Cuttack Development Authority';
const ftMetrics = ctx.measureText(footerText);

// horizontal center
const ftX = infoX + (infoW - ftMetrics.width) / 2;

// vertical center (baseline middle)
const ftY = infoY + infoH - footerHeight / 2 + 5;  
// ‚Üë tuned offset for perfect middle alignment

ctx.textAlign = "left";      // (we use manual centering)
ctx.textBaseline = "middle"; // perfect vertical center
ctx.fillText(footerText, ftX, ftY);


        // final thin inner stroke
        ctx.strokeStyle = 'rgba(0,0,0,0.04)';
        ctx.lineWidth = 1;
        ctx.strokeRect(infoX + 2, infoY + 2, infoW - 4, infoH - 4);

        // download
        exportCanvas.toBlob(function(blob) {
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = 'cuttack_cda_map_export_' + Date.now() + '.png';
          document.body.appendChild(a);
          a.click();
          a.remove();
          setTimeout(()=> URL.revokeObjectURL(url), 3000);
        }, 'image/png');


      } catch (err) {
        alert('Export failed: ' + (err && err.message ? err.message : err));
      }
    });
    map.triggerRepaint();
  } catch (err) {
    alert('Export failed: ' + (err && err.message ? err.message : err));
  }
}
document.getElementById('exportPNG').addEventListener('click', exportMapPNG);
</script>


<!-- LOAD Google Maps JS API (Maps + Street View). Keep KEY restricted to your domain. -->
<script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyBwJnprg61M8EWryIBQxT1_f3qxueLfQic&v=weekly" async defer></script>
</body>
</html>


